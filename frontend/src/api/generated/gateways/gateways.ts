/**
 * Generated by orval v8.3.0 üç∫
 * Do not edit manually.
 * Mission Control API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  GatewayCommandsResponse,
  GatewayCreate,
  GatewayRead,
  GatewaySessionHistoryResponse,
  GatewaySessionMessageRequest,
  GatewaySessionResponse,
  GatewaySessionsResponse,
  GatewayTemplatesSyncResult,
  GatewayUpdate,
  GatewaysStatusApiV1GatewaysStatusGetParams,
  GatewaysStatusResponse,
  GetGatewaySessionApiV1GatewaysSessionsSessionIdGetParams,
  GetSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGetParams,
  HTTPValidationError,
  LimitOffsetPageTypeVarCustomizedGatewayRead,
  ListGatewaySessionsApiV1GatewaysSessionsGetParams,
  ListGatewaysApiV1GatewaysGetParams,
  OkResponse,
  SendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePostParams,
  SyncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPostParams,
} from ".././model";

import { customFetch } from "../../mutator";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Return gateway connectivity and session status.
 * @summary Gateways Status
 */
export type gatewaysStatusApiV1GatewaysStatusGetResponse200 = {
  data: GatewaysStatusResponse;
  status: 200;
};

export type gatewaysStatusApiV1GatewaysStatusGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type gatewaysStatusApiV1GatewaysStatusGetResponseSuccess =
  gatewaysStatusApiV1GatewaysStatusGetResponse200 & {
    headers: Headers;
  };
export type gatewaysStatusApiV1GatewaysStatusGetResponseError =
  gatewaysStatusApiV1GatewaysStatusGetResponse422 & {
    headers: Headers;
  };

export type gatewaysStatusApiV1GatewaysStatusGetResponse =
  | gatewaysStatusApiV1GatewaysStatusGetResponseSuccess
  | gatewaysStatusApiV1GatewaysStatusGetResponseError;

export const getGatewaysStatusApiV1GatewaysStatusGetUrl = (
  params?: GatewaysStatusApiV1GatewaysStatusGetParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/gateways/status?${stringifiedParams}`
    : `/api/v1/gateways/status`;
};

export const gatewaysStatusApiV1GatewaysStatusGet = async (
  params?: GatewaysStatusApiV1GatewaysStatusGetParams,
  options?: RequestInit,
): Promise<gatewaysStatusApiV1GatewaysStatusGetResponse> => {
  return customFetch<gatewaysStatusApiV1GatewaysStatusGetResponse>(
    getGatewaysStatusApiV1GatewaysStatusGetUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGatewaysStatusApiV1GatewaysStatusGetQueryKey = (
  params?: GatewaysStatusApiV1GatewaysStatusGetParams,
) => {
  return [`/api/v1/gateways/status`, ...(params ? [params] : [])] as const;
};

export const getGatewaysStatusApiV1GatewaysStatusGetQueryOptions = <
  TData = Awaited<ReturnType<typeof gatewaysStatusApiV1GatewaysStatusGet>>,
  TError = HTTPValidationError,
>(
  params?: GatewaysStatusApiV1GatewaysStatusGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gatewaysStatusApiV1GatewaysStatusGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGatewaysStatusApiV1GatewaysStatusGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof gatewaysStatusApiV1GatewaysStatusGet>>
  > = ({ signal }) =>
    gatewaysStatusApiV1GatewaysStatusGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gatewaysStatusApiV1GatewaysStatusGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GatewaysStatusApiV1GatewaysStatusGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof gatewaysStatusApiV1GatewaysStatusGet>>
>;
export type GatewaysStatusApiV1GatewaysStatusGetQueryError =
  HTTPValidationError;

export function useGatewaysStatusApiV1GatewaysStatusGet<
  TData = Awaited<ReturnType<typeof gatewaysStatusApiV1GatewaysStatusGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | GatewaysStatusApiV1GatewaysStatusGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gatewaysStatusApiV1GatewaysStatusGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof gatewaysStatusApiV1GatewaysStatusGet>>,
          TError,
          Awaited<ReturnType<typeof gatewaysStatusApiV1GatewaysStatusGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGatewaysStatusApiV1GatewaysStatusGet<
  TData = Awaited<ReturnType<typeof gatewaysStatusApiV1GatewaysStatusGet>>,
  TError = HTTPValidationError,
>(
  params?: GatewaysStatusApiV1GatewaysStatusGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gatewaysStatusApiV1GatewaysStatusGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof gatewaysStatusApiV1GatewaysStatusGet>>,
          TError,
          Awaited<ReturnType<typeof gatewaysStatusApiV1GatewaysStatusGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGatewaysStatusApiV1GatewaysStatusGet<
  TData = Awaited<ReturnType<typeof gatewaysStatusApiV1GatewaysStatusGet>>,
  TError = HTTPValidationError,
>(
  params?: GatewaysStatusApiV1GatewaysStatusGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gatewaysStatusApiV1GatewaysStatusGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Gateways Status
 */

export function useGatewaysStatusApiV1GatewaysStatusGet<
  TData = Awaited<ReturnType<typeof gatewaysStatusApiV1GatewaysStatusGet>>,
  TError = HTTPValidationError,
>(
  params?: GatewaysStatusApiV1GatewaysStatusGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gatewaysStatusApiV1GatewaysStatusGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGatewaysStatusApiV1GatewaysStatusGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * List sessions for a gateway associated with a board.
 * @summary List Gateway Sessions
 */
export type listGatewaySessionsApiV1GatewaysSessionsGetResponse200 = {
  data: GatewaySessionsResponse;
  status: 200;
};

export type listGatewaySessionsApiV1GatewaysSessionsGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type listGatewaySessionsApiV1GatewaysSessionsGetResponseSuccess =
  listGatewaySessionsApiV1GatewaysSessionsGetResponse200 & {
    headers: Headers;
  };
export type listGatewaySessionsApiV1GatewaysSessionsGetResponseError =
  listGatewaySessionsApiV1GatewaysSessionsGetResponse422 & {
    headers: Headers;
  };

export type listGatewaySessionsApiV1GatewaysSessionsGetResponse =
  | listGatewaySessionsApiV1GatewaysSessionsGetResponseSuccess
  | listGatewaySessionsApiV1GatewaysSessionsGetResponseError;

export const getListGatewaySessionsApiV1GatewaysSessionsGetUrl = (
  params?: ListGatewaySessionsApiV1GatewaysSessionsGetParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/gateways/sessions?${stringifiedParams}`
    : `/api/v1/gateways/sessions`;
};

export const listGatewaySessionsApiV1GatewaysSessionsGet = async (
  params?: ListGatewaySessionsApiV1GatewaysSessionsGetParams,
  options?: RequestInit,
): Promise<listGatewaySessionsApiV1GatewaysSessionsGetResponse> => {
  return customFetch<listGatewaySessionsApiV1GatewaysSessionsGetResponse>(
    getListGatewaySessionsApiV1GatewaysSessionsGetUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getListGatewaySessionsApiV1GatewaysSessionsGetQueryKey = (
  params?: ListGatewaySessionsApiV1GatewaysSessionsGetParams,
) => {
  return [`/api/v1/gateways/sessions`, ...(params ? [params] : [])] as const;
};

export const getListGatewaySessionsApiV1GatewaysSessionsGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof listGatewaySessionsApiV1GatewaysSessionsGet>
  >,
  TError = HTTPValidationError,
>(
  params?: ListGatewaySessionsApiV1GatewaysSessionsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listGatewaySessionsApiV1GatewaysSessionsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getListGatewaySessionsApiV1GatewaysSessionsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listGatewaySessionsApiV1GatewaysSessionsGet>>
  > = ({ signal }) =>
    listGatewaySessionsApiV1GatewaysSessionsGet(params, {
      signal,
      ...requestOptions,
    });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listGatewaySessionsApiV1GatewaysSessionsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListGatewaySessionsApiV1GatewaysSessionsGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof listGatewaySessionsApiV1GatewaysSessionsGet>>
  >;
export type ListGatewaySessionsApiV1GatewaysSessionsGetQueryError =
  HTTPValidationError;

export function useListGatewaySessionsApiV1GatewaysSessionsGet<
  TData = Awaited<
    ReturnType<typeof listGatewaySessionsApiV1GatewaysSessionsGet>
  >,
  TError = HTTPValidationError,
>(
  params: undefined | ListGatewaySessionsApiV1GatewaysSessionsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listGatewaySessionsApiV1GatewaysSessionsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof listGatewaySessionsApiV1GatewaysSessionsGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof listGatewaySessionsApiV1GatewaysSessionsGet>
          >
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListGatewaySessionsApiV1GatewaysSessionsGet<
  TData = Awaited<
    ReturnType<typeof listGatewaySessionsApiV1GatewaysSessionsGet>
  >,
  TError = HTTPValidationError,
>(
  params?: ListGatewaySessionsApiV1GatewaysSessionsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listGatewaySessionsApiV1GatewaysSessionsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof listGatewaySessionsApiV1GatewaysSessionsGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof listGatewaySessionsApiV1GatewaysSessionsGet>
          >
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListGatewaySessionsApiV1GatewaysSessionsGet<
  TData = Awaited<
    ReturnType<typeof listGatewaySessionsApiV1GatewaysSessionsGet>
  >,
  TError = HTTPValidationError,
>(
  params?: ListGatewaySessionsApiV1GatewaysSessionsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listGatewaySessionsApiV1GatewaysSessionsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List Gateway Sessions
 */

export function useListGatewaySessionsApiV1GatewaysSessionsGet<
  TData = Awaited<
    ReturnType<typeof listGatewaySessionsApiV1GatewaysSessionsGet>
  >,
  TError = HTTPValidationError,
>(
  params?: ListGatewaySessionsApiV1GatewaysSessionsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listGatewaySessionsApiV1GatewaysSessionsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getListGatewaySessionsApiV1GatewaysSessionsGetQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Get a specific gateway session by key.
 * @summary Get Gateway Session
 */
export type getGatewaySessionApiV1GatewaysSessionsSessionIdGetResponse200 = {
  data: GatewaySessionResponse;
  status: 200;
};

export type getGatewaySessionApiV1GatewaysSessionsSessionIdGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type getGatewaySessionApiV1GatewaysSessionsSessionIdGetResponseSuccess =
  getGatewaySessionApiV1GatewaysSessionsSessionIdGetResponse200 & {
    headers: Headers;
  };
export type getGatewaySessionApiV1GatewaysSessionsSessionIdGetResponseError =
  getGatewaySessionApiV1GatewaysSessionsSessionIdGetResponse422 & {
    headers: Headers;
  };

export type getGatewaySessionApiV1GatewaysSessionsSessionIdGetResponse =
  | getGatewaySessionApiV1GatewaysSessionsSessionIdGetResponseSuccess
  | getGatewaySessionApiV1GatewaysSessionsSessionIdGetResponseError;

export const getGetGatewaySessionApiV1GatewaysSessionsSessionIdGetUrl = (
  sessionId: string,
  params?: GetGatewaySessionApiV1GatewaysSessionsSessionIdGetParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/gateways/sessions/${sessionId}?${stringifiedParams}`
    : `/api/v1/gateways/sessions/${sessionId}`;
};

export const getGatewaySessionApiV1GatewaysSessionsSessionIdGet = async (
  sessionId: string,
  params?: GetGatewaySessionApiV1GatewaysSessionsSessionIdGetParams,
  options?: RequestInit,
): Promise<getGatewaySessionApiV1GatewaysSessionsSessionIdGetResponse> => {
  return customFetch<getGatewaySessionApiV1GatewaysSessionsSessionIdGetResponse>(
    getGetGatewaySessionApiV1GatewaysSessionsSessionIdGetUrl(sessionId, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetGatewaySessionApiV1GatewaysSessionsSessionIdGetQueryKey = (
  sessionId: string,
  params?: GetGatewaySessionApiV1GatewaysSessionsSessionIdGetParams,
) => {
  return [
    `/api/v1/gateways/sessions/${sessionId}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetGatewaySessionApiV1GatewaysSessionsSessionIdGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<typeof getGatewaySessionApiV1GatewaysSessionsSessionIdGet>
    >,
    TError = HTTPValidationError,
  >(
    sessionId: string,
    params?: GetGatewaySessionApiV1GatewaysSessionsSessionIdGetParams,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof getGatewaySessionApiV1GatewaysSessionsSessionIdGet
            >
          >,
          TError,
          TData
        >
      >;
      request?: SecondParameter<typeof customFetch>;
    },
  ) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getGetGatewaySessionApiV1GatewaysSessionsSessionIdGetQueryKey(
        sessionId,
        params,
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<typeof getGatewaySessionApiV1GatewaysSessionsSessionIdGet>
      >
    > = ({ signal }) =>
      getGatewaySessionApiV1GatewaysSessionsSessionIdGet(sessionId, params, {
        signal,
        ...requestOptions,
      });

    return {
      queryKey,
      queryFn,
      enabled: !!sessionId,
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<typeof getGatewaySessionApiV1GatewaysSessionsSessionIdGet>
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
  };

export type GetGatewaySessionApiV1GatewaysSessionsSessionIdGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<typeof getGatewaySessionApiV1GatewaysSessionsSessionIdGet>
    >
  >;
export type GetGatewaySessionApiV1GatewaysSessionsSessionIdGetQueryError =
  HTTPValidationError;

export function useGetGatewaySessionApiV1GatewaysSessionsSessionIdGet<
  TData = Awaited<
    ReturnType<typeof getGatewaySessionApiV1GatewaysSessionsSessionIdGet>
  >,
  TError = HTTPValidationError,
>(
  sessionId: string,
  params: undefined | GetGatewaySessionApiV1GatewaysSessionsSessionIdGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getGatewaySessionApiV1GatewaysSessionsSessionIdGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getGatewaySessionApiV1GatewaysSessionsSessionIdGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getGatewaySessionApiV1GatewaysSessionsSessionIdGet
            >
          >
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGatewaySessionApiV1GatewaysSessionsSessionIdGet<
  TData = Awaited<
    ReturnType<typeof getGatewaySessionApiV1GatewaysSessionsSessionIdGet>
  >,
  TError = HTTPValidationError,
>(
  sessionId: string,
  params?: GetGatewaySessionApiV1GatewaysSessionsSessionIdGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getGatewaySessionApiV1GatewaysSessionsSessionIdGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getGatewaySessionApiV1GatewaysSessionsSessionIdGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getGatewaySessionApiV1GatewaysSessionsSessionIdGet
            >
          >
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGatewaySessionApiV1GatewaysSessionsSessionIdGet<
  TData = Awaited<
    ReturnType<typeof getGatewaySessionApiV1GatewaysSessionsSessionIdGet>
  >,
  TError = HTTPValidationError,
>(
  sessionId: string,
  params?: GetGatewaySessionApiV1GatewaysSessionsSessionIdGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getGatewaySessionApiV1GatewaysSessionsSessionIdGet>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Gateway Session
 */

export function useGetGatewaySessionApiV1GatewaysSessionsSessionIdGet<
  TData = Awaited<
    ReturnType<typeof getGatewaySessionApiV1GatewaysSessionsSessionIdGet>
  >,
  TError = HTTPValidationError,
>(
  sessionId: string,
  params?: GetGatewaySessionApiV1GatewaysSessionsSessionIdGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getGatewaySessionApiV1GatewaysSessionsSessionIdGet>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getGetGatewaySessionApiV1GatewaysSessionsSessionIdGetQueryOptions(
      sessionId,
      params,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Fetch chat history for a gateway session.
 * @summary Get Session History
 */
export type getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGetResponse200 =
  {
    data: GatewaySessionHistoryResponse;
    status: 200;
  };

export type getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGetResponse422 =
  {
    data: HTTPValidationError;
    status: 422;
  };

export type getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGetResponseSuccess =
  getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGetResponse200 & {
    headers: Headers;
  };
export type getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGetResponseError =
  getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGetResponse422 & {
    headers: Headers;
  };

export type getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGetResponse =
  | getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGetResponseSuccess
  | getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGetResponseError;

export const getGetSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGetUrl = (
  sessionId: string,
  params?: GetSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGetParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/gateways/sessions/${sessionId}/history?${stringifiedParams}`
    : `/api/v1/gateways/sessions/${sessionId}/history`;
};

export const getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGet = async (
  sessionId: string,
  params?: GetSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGetParams,
  options?: RequestInit,
): Promise<getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGetResponse> => {
  return customFetch<getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGetResponse>(
    getGetSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGetUrl(
      sessionId,
      params,
    ),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGetQueryKey =
  (
    sessionId: string,
    params?: GetSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGetParams,
  ) => {
    return [
      `/api/v1/gateways/sessions/${sessionId}/history`,
      ...(params ? [params] : []),
    ] as const;
  };

export const getGetSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<
        typeof getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGet
      >
    >,
    TError = HTTPValidationError,
  >(
    sessionId: string,
    params?: GetSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGetParams,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGet
            >
          >,
          TError,
          TData
        >
      >;
      request?: SecondParameter<typeof customFetch>;
    },
  ) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getGetSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGetQueryKey(
        sessionId,
        params,
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGet
        >
      >
    > = ({ signal }) =>
      getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGet(
        sessionId,
        params,
        { signal, ...requestOptions },
      );

    return {
      queryKey,
      queryFn,
      enabled: !!sessionId,
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGet
        >
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
  };

export type GetSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGet
      >
    >
  >;
export type GetSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGetQueryError =
  HTTPValidationError;

export function useGetSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGet<
  TData = Awaited<
    ReturnType<typeof getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGet>
  >,
  TError = HTTPValidationError,
>(
  sessionId: string,
  params:
    | undefined
    | GetSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGet
            >
          >
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGet<
  TData = Awaited<
    ReturnType<typeof getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGet>
  >,
  TError = HTTPValidationError,
>(
  sessionId: string,
  params?: GetSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGet
            >
          >
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGet<
  TData = Awaited<
    ReturnType<typeof getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGet>
  >,
  TError = HTTPValidationError,
>(
  sessionId: string,
  params?: GetSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGet
          >
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Session History
 */

export function useGetSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGet<
  TData = Awaited<
    ReturnType<typeof getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGet>
  >,
  TError = HTTPValidationError,
>(
  sessionId: string,
  params?: GetSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGet
          >
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getGetSessionHistoryApiV1GatewaysSessionsSessionIdHistoryGetQueryOptions(
      sessionId,
      params,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Send a message into a specific gateway session.
 * @summary Send Gateway Session Message
 */
export type sendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePostResponse200 =
  {
    data: OkResponse;
    status: 200;
  };

export type sendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePostResponse422 =
  {
    data: HTTPValidationError;
    status: 422;
  };

export type sendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePostResponseSuccess =
  sendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePostResponse200 & {
    headers: Headers;
  };
export type sendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePostResponseError =
  sendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePostResponse422 & {
    headers: Headers;
  };

export type sendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePostResponse =

    | sendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePostResponseSuccess
    | sendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePostResponseError;

export const getSendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePostUrl =
  (
    sessionId: string,
    params?: SendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePostParams,
  ) => {
    const normalizedParams = new URLSearchParams();

    Object.entries(params || {}).forEach(([key, value]) => {
      if (value !== undefined) {
        normalizedParams.append(
          key,
          value === null ? "null" : value.toString(),
        );
      }
    });

    const stringifiedParams = normalizedParams.toString();

    return stringifiedParams.length > 0
      ? `/api/v1/gateways/sessions/${sessionId}/message?${stringifiedParams}`
      : `/api/v1/gateways/sessions/${sessionId}/message`;
  };

export const sendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePost =
  async (
    sessionId: string,
    gatewaySessionMessageRequest: GatewaySessionMessageRequest,
    params?: SendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePostParams,
    options?: RequestInit,
  ): Promise<sendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePostResponse> => {
    return customFetch<sendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePostResponse>(
      getSendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePostUrl(
        sessionId,
        params,
      ),
      {
        ...options,
        method: "POST",
        headers: { "Content-Type": "application/json", ...options?.headers },
        body: JSON.stringify(gatewaySessionMessageRequest),
      },
    );
  };

export const getSendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePostMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof sendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePost
        >
      >,
      TError,
      {
        sessionId: string;
        data: GatewaySessionMessageRequest;
        params?: SendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePostParams;
      },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof sendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePost
      >
    >,
    TError,
    {
      sessionId: string;
      data: GatewaySessionMessageRequest;
      params?: SendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePostParams;
    },
    TContext
  > => {
    const mutationKey = [
      "sendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePost",
    ];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof sendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePost
        >
      >,
      {
        sessionId: string;
        data: GatewaySessionMessageRequest;
        params?: SendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePostParams;
      }
    > = (props) => {
      const { sessionId, data, params } = props ?? {};

      return sendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePost(
        sessionId,
        data,
        params,
        requestOptions,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type SendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof sendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePost
      >
    >
  >;
export type SendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePostMutationBody =
  GatewaySessionMessageRequest;
export type SendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePostMutationError =
  HTTPValidationError;

/**
 * @summary Send Gateway Session Message
 */
export const useSendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePost =
  <TError = HTTPValidationError, TContext = unknown>(
    options?: {
      mutation?: UseMutationOptions<
        Awaited<
          ReturnType<
            typeof sendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePost
          >
        >,
        TError,
        {
          sessionId: string;
          data: GatewaySessionMessageRequest;
          params?: SendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePostParams;
        },
        TContext
      >;
      request?: SecondParameter<typeof customFetch>;
    },
    queryClient?: QueryClient,
  ): UseMutationResult<
    Awaited<
      ReturnType<
        typeof sendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePost
      >
    >,
    TError,
    {
      sessionId: string;
      data: GatewaySessionMessageRequest;
      params?: SendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePostParams;
    },
    TContext
  > => {
    return useMutation(
      getSendGatewaySessionMessageApiV1GatewaysSessionsSessionIdMessagePostMutationOptions(
        options,
      ),
      queryClient,
    );
  };
/**
 * Return supported gateway protocol methods and events.
 * @summary Gateway Commands
 */
export type gatewayCommandsApiV1GatewaysCommandsGetResponse200 = {
  data: GatewayCommandsResponse;
  status: 200;
};

export type gatewayCommandsApiV1GatewaysCommandsGetResponseSuccess =
  gatewayCommandsApiV1GatewaysCommandsGetResponse200 & {
    headers: Headers;
  };
export type gatewayCommandsApiV1GatewaysCommandsGetResponse =
  gatewayCommandsApiV1GatewaysCommandsGetResponseSuccess;

export const getGatewayCommandsApiV1GatewaysCommandsGetUrl = () => {
  return `/api/v1/gateways/commands`;
};

export const gatewayCommandsApiV1GatewaysCommandsGet = async (
  options?: RequestInit,
): Promise<gatewayCommandsApiV1GatewaysCommandsGetResponse> => {
  return customFetch<gatewayCommandsApiV1GatewaysCommandsGetResponse>(
    getGatewayCommandsApiV1GatewaysCommandsGetUrl(),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGatewayCommandsApiV1GatewaysCommandsGetQueryKey = () => {
  return [`/api/v1/gateways/commands`] as const;
};

export const getGatewayCommandsApiV1GatewaysCommandsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof gatewayCommandsApiV1GatewaysCommandsGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof gatewayCommandsApiV1GatewaysCommandsGet>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGatewayCommandsApiV1GatewaysCommandsGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof gatewayCommandsApiV1GatewaysCommandsGet>>
  > = ({ signal }) =>
    gatewayCommandsApiV1GatewaysCommandsGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gatewayCommandsApiV1GatewaysCommandsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GatewayCommandsApiV1GatewaysCommandsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof gatewayCommandsApiV1GatewaysCommandsGet>>
>;
export type GatewayCommandsApiV1GatewaysCommandsGetQueryError = unknown;

export function useGatewayCommandsApiV1GatewaysCommandsGet<
  TData = Awaited<ReturnType<typeof gatewayCommandsApiV1GatewaysCommandsGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gatewayCommandsApiV1GatewaysCommandsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof gatewayCommandsApiV1GatewaysCommandsGet>>,
          TError,
          Awaited<ReturnType<typeof gatewayCommandsApiV1GatewaysCommandsGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGatewayCommandsApiV1GatewaysCommandsGet<
  TData = Awaited<ReturnType<typeof gatewayCommandsApiV1GatewaysCommandsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gatewayCommandsApiV1GatewaysCommandsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof gatewayCommandsApiV1GatewaysCommandsGet>>,
          TError,
          Awaited<ReturnType<typeof gatewayCommandsApiV1GatewaysCommandsGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGatewayCommandsApiV1GatewaysCommandsGet<
  TData = Awaited<ReturnType<typeof gatewayCommandsApiV1GatewaysCommandsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gatewayCommandsApiV1GatewaysCommandsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Gateway Commands
 */

export function useGatewayCommandsApiV1GatewaysCommandsGet<
  TData = Awaited<ReturnType<typeof gatewayCommandsApiV1GatewaysCommandsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gatewayCommandsApiV1GatewaysCommandsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getGatewayCommandsApiV1GatewaysCommandsGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * List gateways for the caller's organization.
 * @summary List Gateways
 */
export type listGatewaysApiV1GatewaysGetResponse200 = {
  data: LimitOffsetPageTypeVarCustomizedGatewayRead;
  status: 200;
};

export type listGatewaysApiV1GatewaysGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type listGatewaysApiV1GatewaysGetResponseSuccess =
  listGatewaysApiV1GatewaysGetResponse200 & {
    headers: Headers;
  };
export type listGatewaysApiV1GatewaysGetResponseError =
  listGatewaysApiV1GatewaysGetResponse422 & {
    headers: Headers;
  };

export type listGatewaysApiV1GatewaysGetResponse =
  | listGatewaysApiV1GatewaysGetResponseSuccess
  | listGatewaysApiV1GatewaysGetResponseError;

export const getListGatewaysApiV1GatewaysGetUrl = (
  params?: ListGatewaysApiV1GatewaysGetParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/gateways?${stringifiedParams}`
    : `/api/v1/gateways`;
};

export const listGatewaysApiV1GatewaysGet = async (
  params?: ListGatewaysApiV1GatewaysGetParams,
  options?: RequestInit,
): Promise<listGatewaysApiV1GatewaysGetResponse> => {
  return customFetch<listGatewaysApiV1GatewaysGetResponse>(
    getListGatewaysApiV1GatewaysGetUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getListGatewaysApiV1GatewaysGetQueryKey = (
  params?: ListGatewaysApiV1GatewaysGetParams,
) => {
  return [`/api/v1/gateways`, ...(params ? [params] : [])] as const;
};

export const getListGatewaysApiV1GatewaysGetQueryOptions = <
  TData = Awaited<ReturnType<typeof listGatewaysApiV1GatewaysGet>>,
  TError = HTTPValidationError,
>(
  params?: ListGatewaysApiV1GatewaysGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listGatewaysApiV1GatewaysGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getListGatewaysApiV1GatewaysGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listGatewaysApiV1GatewaysGet>>
  > = ({ signal }) =>
    listGatewaysApiV1GatewaysGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listGatewaysApiV1GatewaysGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListGatewaysApiV1GatewaysGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof listGatewaysApiV1GatewaysGet>>
>;
export type ListGatewaysApiV1GatewaysGetQueryError = HTTPValidationError;

export function useListGatewaysApiV1GatewaysGet<
  TData = Awaited<ReturnType<typeof listGatewaysApiV1GatewaysGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | ListGatewaysApiV1GatewaysGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listGatewaysApiV1GatewaysGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listGatewaysApiV1GatewaysGet>>,
          TError,
          Awaited<ReturnType<typeof listGatewaysApiV1GatewaysGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListGatewaysApiV1GatewaysGet<
  TData = Awaited<ReturnType<typeof listGatewaysApiV1GatewaysGet>>,
  TError = HTTPValidationError,
>(
  params?: ListGatewaysApiV1GatewaysGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listGatewaysApiV1GatewaysGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listGatewaysApiV1GatewaysGet>>,
          TError,
          Awaited<ReturnType<typeof listGatewaysApiV1GatewaysGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListGatewaysApiV1GatewaysGet<
  TData = Awaited<ReturnType<typeof listGatewaysApiV1GatewaysGet>>,
  TError = HTTPValidationError,
>(
  params?: ListGatewaysApiV1GatewaysGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listGatewaysApiV1GatewaysGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List Gateways
 */

export function useListGatewaysApiV1GatewaysGet<
  TData = Awaited<ReturnType<typeof listGatewaysApiV1GatewaysGet>>,
  TError = HTTPValidationError,
>(
  params?: ListGatewaysApiV1GatewaysGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listGatewaysApiV1GatewaysGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getListGatewaysApiV1GatewaysGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Create a gateway and provision or refresh its main agent.
 * @summary Create Gateway
 */
export type createGatewayApiV1GatewaysPostResponse200 = {
  data: GatewayRead;
  status: 200;
};

export type createGatewayApiV1GatewaysPostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type createGatewayApiV1GatewaysPostResponseSuccess =
  createGatewayApiV1GatewaysPostResponse200 & {
    headers: Headers;
  };
export type createGatewayApiV1GatewaysPostResponseError =
  createGatewayApiV1GatewaysPostResponse422 & {
    headers: Headers;
  };

export type createGatewayApiV1GatewaysPostResponse =
  | createGatewayApiV1GatewaysPostResponseSuccess
  | createGatewayApiV1GatewaysPostResponseError;

export const getCreateGatewayApiV1GatewaysPostUrl = () => {
  return `/api/v1/gateways`;
};

export const createGatewayApiV1GatewaysPost = async (
  gatewayCreate: GatewayCreate,
  options?: RequestInit,
): Promise<createGatewayApiV1GatewaysPostResponse> => {
  return customFetch<createGatewayApiV1GatewaysPostResponse>(
    getCreateGatewayApiV1GatewaysPostUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(gatewayCreate),
    },
  );
};

export const getCreateGatewayApiV1GatewaysPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createGatewayApiV1GatewaysPost>>,
    TError,
    { data: GatewayCreate },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createGatewayApiV1GatewaysPost>>,
  TError,
  { data: GatewayCreate },
  TContext
> => {
  const mutationKey = ["createGatewayApiV1GatewaysPost"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createGatewayApiV1GatewaysPost>>,
    { data: GatewayCreate }
  > = (props) => {
    const { data } = props ?? {};

    return createGatewayApiV1GatewaysPost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateGatewayApiV1GatewaysPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createGatewayApiV1GatewaysPost>>
>;
export type CreateGatewayApiV1GatewaysPostMutationBody = GatewayCreate;
export type CreateGatewayApiV1GatewaysPostMutationError = HTTPValidationError;

/**
 * @summary Create Gateway
 */
export const useCreateGatewayApiV1GatewaysPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createGatewayApiV1GatewaysPost>>,
      TError,
      { data: GatewayCreate },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createGatewayApiV1GatewaysPost>>,
  TError,
  { data: GatewayCreate },
  TContext
> => {
  return useMutation(
    getCreateGatewayApiV1GatewaysPostMutationOptions(options),
    queryClient,
  );
};
/**
 * Return one gateway by id for the caller's organization.
 * @summary Get Gateway
 */
export type getGatewayApiV1GatewaysGatewayIdGetResponse200 = {
  data: GatewayRead;
  status: 200;
};

export type getGatewayApiV1GatewaysGatewayIdGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type getGatewayApiV1GatewaysGatewayIdGetResponseSuccess =
  getGatewayApiV1GatewaysGatewayIdGetResponse200 & {
    headers: Headers;
  };
export type getGatewayApiV1GatewaysGatewayIdGetResponseError =
  getGatewayApiV1GatewaysGatewayIdGetResponse422 & {
    headers: Headers;
  };

export type getGatewayApiV1GatewaysGatewayIdGetResponse =
  | getGatewayApiV1GatewaysGatewayIdGetResponseSuccess
  | getGatewayApiV1GatewaysGatewayIdGetResponseError;

export const getGetGatewayApiV1GatewaysGatewayIdGetUrl = (
  gatewayId: string,
) => {
  return `/api/v1/gateways/${gatewayId}`;
};

export const getGatewayApiV1GatewaysGatewayIdGet = async (
  gatewayId: string,
  options?: RequestInit,
): Promise<getGatewayApiV1GatewaysGatewayIdGetResponse> => {
  return customFetch<getGatewayApiV1GatewaysGatewayIdGetResponse>(
    getGetGatewayApiV1GatewaysGatewayIdGetUrl(gatewayId),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetGatewayApiV1GatewaysGatewayIdGetQueryKey = (
  gatewayId: string,
) => {
  return [`/api/v1/gateways/${gatewayId}`] as const;
};

export const getGetGatewayApiV1GatewaysGatewayIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getGatewayApiV1GatewaysGatewayIdGet>>,
  TError = HTTPValidationError,
>(
  gatewayId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGatewayApiV1GatewaysGatewayIdGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetGatewayApiV1GatewaysGatewayIdGetQueryKey(gatewayId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getGatewayApiV1GatewaysGatewayIdGet>>
  > = ({ signal }) =>
    getGatewayApiV1GatewaysGatewayIdGet(gatewayId, {
      signal,
      ...requestOptions,
    });

  return {
    queryKey,
    queryFn,
    enabled: !!gatewayId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getGatewayApiV1GatewaysGatewayIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetGatewayApiV1GatewaysGatewayIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGatewayApiV1GatewaysGatewayIdGet>>
>;
export type GetGatewayApiV1GatewaysGatewayIdGetQueryError = HTTPValidationError;

export function useGetGatewayApiV1GatewaysGatewayIdGet<
  TData = Awaited<ReturnType<typeof getGatewayApiV1GatewaysGatewayIdGet>>,
  TError = HTTPValidationError,
>(
  gatewayId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGatewayApiV1GatewaysGatewayIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGatewayApiV1GatewaysGatewayIdGet>>,
          TError,
          Awaited<ReturnType<typeof getGatewayApiV1GatewaysGatewayIdGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGatewayApiV1GatewaysGatewayIdGet<
  TData = Awaited<ReturnType<typeof getGatewayApiV1GatewaysGatewayIdGet>>,
  TError = HTTPValidationError,
>(
  gatewayId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGatewayApiV1GatewaysGatewayIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGatewayApiV1GatewaysGatewayIdGet>>,
          TError,
          Awaited<ReturnType<typeof getGatewayApiV1GatewaysGatewayIdGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGatewayApiV1GatewaysGatewayIdGet<
  TData = Awaited<ReturnType<typeof getGatewayApiV1GatewaysGatewayIdGet>>,
  TError = HTTPValidationError,
>(
  gatewayId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGatewayApiV1GatewaysGatewayIdGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Gateway
 */

export function useGetGatewayApiV1GatewaysGatewayIdGet<
  TData = Awaited<ReturnType<typeof getGatewayApiV1GatewaysGatewayIdGet>>,
  TError = HTTPValidationError,
>(
  gatewayId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGatewayApiV1GatewaysGatewayIdGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetGatewayApiV1GatewaysGatewayIdGetQueryOptions(
    gatewayId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Patch a gateway and refresh the main-agent provisioning state.
 * @summary Update Gateway
 */
export type updateGatewayApiV1GatewaysGatewayIdPatchResponse200 = {
  data: GatewayRead;
  status: 200;
};

export type updateGatewayApiV1GatewaysGatewayIdPatchResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type updateGatewayApiV1GatewaysGatewayIdPatchResponseSuccess =
  updateGatewayApiV1GatewaysGatewayIdPatchResponse200 & {
    headers: Headers;
  };
export type updateGatewayApiV1GatewaysGatewayIdPatchResponseError =
  updateGatewayApiV1GatewaysGatewayIdPatchResponse422 & {
    headers: Headers;
  };

export type updateGatewayApiV1GatewaysGatewayIdPatchResponse =
  | updateGatewayApiV1GatewaysGatewayIdPatchResponseSuccess
  | updateGatewayApiV1GatewaysGatewayIdPatchResponseError;

export const getUpdateGatewayApiV1GatewaysGatewayIdPatchUrl = (
  gatewayId: string,
) => {
  return `/api/v1/gateways/${gatewayId}`;
};

export const updateGatewayApiV1GatewaysGatewayIdPatch = async (
  gatewayId: string,
  gatewayUpdate: GatewayUpdate,
  options?: RequestInit,
): Promise<updateGatewayApiV1GatewaysGatewayIdPatchResponse> => {
  return customFetch<updateGatewayApiV1GatewaysGatewayIdPatchResponse>(
    getUpdateGatewayApiV1GatewaysGatewayIdPatchUrl(gatewayId),
    {
      ...options,
      method: "PATCH",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(gatewayUpdate),
    },
  );
};

export const getUpdateGatewayApiV1GatewaysGatewayIdPatchMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateGatewayApiV1GatewaysGatewayIdPatch>>,
    TError,
    { gatewayId: string; data: GatewayUpdate },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateGatewayApiV1GatewaysGatewayIdPatch>>,
  TError,
  { gatewayId: string; data: GatewayUpdate },
  TContext
> => {
  const mutationKey = ["updateGatewayApiV1GatewaysGatewayIdPatch"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateGatewayApiV1GatewaysGatewayIdPatch>>,
    { gatewayId: string; data: GatewayUpdate }
  > = (props) => {
    const { gatewayId, data } = props ?? {};

    return updateGatewayApiV1GatewaysGatewayIdPatch(
      gatewayId,
      data,
      requestOptions,
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateGatewayApiV1GatewaysGatewayIdPatchMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof updateGatewayApiV1GatewaysGatewayIdPatch>>
  >;
export type UpdateGatewayApiV1GatewaysGatewayIdPatchMutationBody =
  GatewayUpdate;
export type UpdateGatewayApiV1GatewaysGatewayIdPatchMutationError =
  HTTPValidationError;

/**
 * @summary Update Gateway
 */
export const useUpdateGatewayApiV1GatewaysGatewayIdPatch = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateGatewayApiV1GatewaysGatewayIdPatch>>,
      TError,
      { gatewayId: string; data: GatewayUpdate },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateGatewayApiV1GatewaysGatewayIdPatch>>,
  TError,
  { gatewayId: string; data: GatewayUpdate },
  TContext
> => {
  return useMutation(
    getUpdateGatewayApiV1GatewaysGatewayIdPatchMutationOptions(options),
    queryClient,
  );
};
/**
 * Delete a gateway in the caller's organization.
 * @summary Delete Gateway
 */
export type deleteGatewayApiV1GatewaysGatewayIdDeleteResponse200 = {
  data: OkResponse;
  status: 200;
};

export type deleteGatewayApiV1GatewaysGatewayIdDeleteResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type deleteGatewayApiV1GatewaysGatewayIdDeleteResponseSuccess =
  deleteGatewayApiV1GatewaysGatewayIdDeleteResponse200 & {
    headers: Headers;
  };
export type deleteGatewayApiV1GatewaysGatewayIdDeleteResponseError =
  deleteGatewayApiV1GatewaysGatewayIdDeleteResponse422 & {
    headers: Headers;
  };

export type deleteGatewayApiV1GatewaysGatewayIdDeleteResponse =
  | deleteGatewayApiV1GatewaysGatewayIdDeleteResponseSuccess
  | deleteGatewayApiV1GatewaysGatewayIdDeleteResponseError;

export const getDeleteGatewayApiV1GatewaysGatewayIdDeleteUrl = (
  gatewayId: string,
) => {
  return `/api/v1/gateways/${gatewayId}`;
};

export const deleteGatewayApiV1GatewaysGatewayIdDelete = async (
  gatewayId: string,
  options?: RequestInit,
): Promise<deleteGatewayApiV1GatewaysGatewayIdDeleteResponse> => {
  return customFetch<deleteGatewayApiV1GatewaysGatewayIdDeleteResponse>(
    getDeleteGatewayApiV1GatewaysGatewayIdDeleteUrl(gatewayId),
    {
      ...options,
      method: "DELETE",
    },
  );
};

export const getDeleteGatewayApiV1GatewaysGatewayIdDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteGatewayApiV1GatewaysGatewayIdDelete>>,
    TError,
    { gatewayId: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteGatewayApiV1GatewaysGatewayIdDelete>>,
  TError,
  { gatewayId: string },
  TContext
> => {
  const mutationKey = ["deleteGatewayApiV1GatewaysGatewayIdDelete"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteGatewayApiV1GatewaysGatewayIdDelete>>,
    { gatewayId: string }
  > = (props) => {
    const { gatewayId } = props ?? {};

    return deleteGatewayApiV1GatewaysGatewayIdDelete(gatewayId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteGatewayApiV1GatewaysGatewayIdDeleteMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof deleteGatewayApiV1GatewaysGatewayIdDelete>>
  >;

export type DeleteGatewayApiV1GatewaysGatewayIdDeleteMutationError =
  HTTPValidationError;

/**
 * @summary Delete Gateway
 */
export const useDeleteGatewayApiV1GatewaysGatewayIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteGatewayApiV1GatewaysGatewayIdDelete>>,
      TError,
      { gatewayId: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteGatewayApiV1GatewaysGatewayIdDelete>>,
  TError,
  { gatewayId: string },
  TContext
> => {
  return useMutation(
    getDeleteGatewayApiV1GatewaysGatewayIdDeleteMutationOptions(options),
    queryClient,
  );
};
/**
 * Sync templates for a gateway and optionally rotate runtime settings.
 * @summary Sync Gateway Templates
 */
export type syncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPostResponse200 =
  {
    data: GatewayTemplatesSyncResult;
    status: 200;
  };

export type syncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPostResponse422 =
  {
    data: HTTPValidationError;
    status: 422;
  };

export type syncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPostResponseSuccess =
  syncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPostResponse200 & {
    headers: Headers;
  };
export type syncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPostResponseError =
  syncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPostResponse422 & {
    headers: Headers;
  };

export type syncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPostResponse =

    | syncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPostResponseSuccess
    | syncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPostResponseError;

export const getSyncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPostUrl =
  (
    gatewayId: string,
    params?: SyncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPostParams,
  ) => {
    const normalizedParams = new URLSearchParams();

    Object.entries(params || {}).forEach(([key, value]) => {
      if (value !== undefined) {
        normalizedParams.append(
          key,
          value === null ? "null" : value.toString(),
        );
      }
    });

    const stringifiedParams = normalizedParams.toString();

    return stringifiedParams.length > 0
      ? `/api/v1/gateways/${gatewayId}/templates/sync?${stringifiedParams}`
      : `/api/v1/gateways/${gatewayId}/templates/sync`;
  };

export const syncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPost =
  async (
    gatewayId: string,
    params?: SyncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPostParams,
    options?: RequestInit,
  ): Promise<syncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPostResponse> => {
    return customFetch<syncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPostResponse>(
      getSyncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPostUrl(
        gatewayId,
        params,
      ),
      {
        ...options,
        method: "POST",
      },
    );
  };

export const getSyncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPostMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof syncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPost
        >
      >,
      TError,
      {
        gatewayId: string;
        params?: SyncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPostParams;
      },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof syncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPost
      >
    >,
    TError,
    {
      gatewayId: string;
      params?: SyncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPostParams;
    },
    TContext
  > => {
    const mutationKey = [
      "syncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPost",
    ];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof syncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPost
        >
      >,
      {
        gatewayId: string;
        params?: SyncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPostParams;
      }
    > = (props) => {
      const { gatewayId, params } = props ?? {};

      return syncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPost(
        gatewayId,
        params,
        requestOptions,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type SyncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof syncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPost
      >
    >
  >;

export type SyncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPostMutationError =
  HTTPValidationError;

/**
 * @summary Sync Gateway Templates
 */
export const useSyncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof syncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPost
        >
      >,
      TError,
      {
        gatewayId: string;
        params?: SyncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPostParams;
      },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<
    ReturnType<
      typeof syncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPost
    >
  >,
  TError,
  {
    gatewayId: string;
    params?: SyncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPostParams;
  },
  TContext
> => {
  return useMutation(
    getSyncGatewayTemplatesApiV1GatewaysGatewayIdTemplatesSyncPostMutationOptions(
      options,
    ),
    queryClient,
  );
};
